<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/media/rou/Seagate Expansion Drive/Programming_Projects/Linux2018/Tests/blender/doc/python_api/sphinx-in/info_gotcha.rst">
    <section ids="gotchas" names="gotchas">
        <title>Gotchas</title>
        <paragraph>This document attempts to help you work with the Blender API in areas
            that can be troublesome and avoid practices that are known to give instability.</paragraph>
        <target refid="using-operators"></target>
        <section ids="using-operators id1" names="using\ operators using_operators">
            <title>Using Operators</title>
            <paragraph>Blender’s operators are tools for users to access, that Python can access them too is very useful
                nevertheless operators have limitations that can make them cumbersome to script.</paragraph>
            <paragraph>Main limits are…</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Can’t pass data such as objects, meshes or materials to operate on (operators use the context instead)</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The return value from calling an operator gives the success (if it finished or was canceled),
                        in some cases it would be more logical from an API perspective to return the result of the operation.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Operators poll function can fail where an API function would raise an exception giving details on exactly why.</paragraph>
                </list_item>
            </bullet_list>
            <section ids="why-does-an-operator-s-poll-fail" names="why\ does\ an\ operator's\ poll\ fail?">
                <title>Why does an operator’s poll fail?</title>
                <paragraph>When calling an operator gives an error like this:</paragraph>
                <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.ops.action.clean(threshold=0.001)
RuntimeError: Operator bpy.ops.action.clean.poll() failed, context is incorrect</doctest_block>
                <paragraph>Which raises the question as to what the correct context might be?</paragraph>
                <paragraph>Typically operators check for the active area type, a selection or active object they can operate on,
                    but some operators are more picky about when they run.</paragraph>
                <paragraph>In most cases you can figure out what context an operator needs
                    simply be seeing how it’s used in Blender and thinking about what it does.</paragraph>
                <paragraph>Unfortunately if you’re still stuck - the only way to <strong>really</strong> know
                    whats going on is to read the source code for the poll function and see what its checking.</paragraph>
                <paragraph>For Python operators it’s not so hard to find the source
                    since it’s included with Blender and the source file/line is included in the operator reference docs.</paragraph>
                <paragraph>Downloading and searching the C code isn’t so simple,
                    especially if you’re not familiar with the C language but by searching the
                    operator name or description you should be able to find the poll function with no knowledge of C.</paragraph>
                <note>
                    <paragraph>Blender does have the functionality for poll functions to describe why they fail,
                        but its currently not used much, if you’re interested to help improve our API
                        feel free to add calls to <literal>CTX_wm_operator_poll_msg_set</literal> where its not obvious why poll fails.</paragraph>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.ops.gpencil.draw()
RuntimeError: Operator bpy.ops.gpencil.draw.poll() Failed to find Grease Pencil data to draw into</doctest_block>
                </note>
            </section>
            <section ids="the-operator-still-doesn-t-work" names="the\ operator\ still\ doesn't\ work!">
                <title>The operator still doesn’t work!</title>
                <paragraph>Certain operators in Blender are only intended for use in a specific context,
                    some operators for example are only called from the properties window where they check the current material,
                    modifier or constraint.</paragraph>
                <paragraph>Examples of this are:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference internal="True" reftitle="bpy.ops.texture.slot_move" refuri="bpy.ops.texture#bpy.ops.texture.slot_move"><literal classes="xref py py-mod">bpy.ops.texture.slot_move</literal></reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="True" reftitle="bpy.ops.constraint.limitdistance_reset" refuri="bpy.ops.constraint#bpy.ops.constraint.limitdistance_reset"><literal classes="xref py py-mod">bpy.ops.constraint.limitdistance_reset</literal></reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="True" reftitle="bpy.ops.object.modifier_copy" refuri="bpy.ops.object#bpy.ops.object.modifier_copy"><literal classes="xref py py-mod">bpy.ops.object.modifier_copy</literal></reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="True" reftitle="bpy.ops.buttons.file_browse" refuri="bpy.ops.buttons#bpy.ops.buttons.file_browse"><literal classes="xref py py-mod">bpy.ops.buttons.file_browse</literal></reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Another possibility is that you are the first person to attempt to use this operator
                    in a script and some modifications need to be made to the operator to run in a different context,
                    if the operator should logically be able to run but fails when accessed from a script
                    it should be reported to the bug tracker.</paragraph>
            </section>
        </section>
        <section ids="stale-data" names="stale\ data">
            <title>Stale Data</title>
            <section ids="no-updates-after-setting-values" names="no\ updates\ after\ setting\ values">
                <title>No updates after setting values</title>
                <paragraph>Sometimes you want to modify values from Python and immediately access the updated values, eg:</paragraph>
                <paragraph>Once changing the objects <reference internal="True" reftitle="bpy.types.Object.location" refuri="bpy.types.Object#bpy.types.Object.location"><literal classes="xref py py-class">bpy.types.Object.location</literal></reference>
                    you may want to access its transformation right after from <reference internal="True" reftitle="bpy.types.Object.matrix_world" refuri="bpy.types.Object#bpy.types.Object.matrix_world"><literal classes="xref py py-class">bpy.types.Object.matrix_world</literal></reference>,
                    but this doesn’t work as you might expect.</paragraph>
                <paragraph>Consider the calculations that might go into working out the object’s final transformation, this includes:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>animation function curves.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>drivers and their Python expressions.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>constraints</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>parent objects and all of their f-curves, constraints etc.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>To avoid expensive recalculations every time a property is modified,
                    Blender defers making the actual calculations until they are needed.</paragraph>
                <paragraph>However, while the script runs you may want to access the updated values.
                    In this case you need to call <reference internal="True" reftitle="bpy.types.Scene.update" refuri="bpy.types.Scene#bpy.types.Scene.update"><literal classes="xref py py-class">bpy.types.Scene.update</literal></reference> after modifying values, for example:</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.context.object.location = 1, 2, 3
bpy.context.scene.update()</literal_block>
                <paragraph>Now all dependent data (child objects, modifiers, drivers… etc)
                    has been recalculated and is available to the script.</paragraph>
            </section>
            <section ids="can-i-redraw-during-the-script" names="can\ i\ redraw\ during\ the\ script?">
                <title>Can I redraw during the script?</title>
                <paragraph>The official answer to this is no, or… <emphasis>“You don’t want to do that”</emphasis>.</paragraph>
                <paragraph>To give some background on the topic…</paragraph>
                <paragraph>While a script executes Blender waits for it to finish and is effectively locked until its done,
                    while in this state Blender won’t redraw or respond to user input.
                    Normally this is not such a problem because scripts distributed with Blender
                    tend not to run for an extended period of time,
                    nevertheless scripts <emphasis>can</emphasis> take ages to execute and its nice to see whats going on in the view port.</paragraph>
                <paragraph>Tools that lock Blender in a loop and redraw are highly discouraged
                    since they conflict with Blenders ability to run multiple operators
                    at once and update different parts of the interface as the tool runs.</paragraph>
                <paragraph>So the solution here is to write a <strong>modal</strong> operator, that is - an operator which defines a modal() function,
                    See the modal operator template in the text  editor.</paragraph>
                <paragraph>Modal operators execute on user input or setup their own timers to run frequently,
                    they can handle the events or pass through to be handled by the keymap or other modal operators.</paragraph>
                <paragraph>Transform, Painting, Fly-Mode and File-Select are example of a modal operators.</paragraph>
                <paragraph>Writing modal operators takes more effort than a simple <literal>for</literal> loop
                    that happens to redraw but is more flexible and integrates better with Blenders design.</paragraph>
                <paragraph><strong>Ok, Ok! I still want to draw from Python</strong></paragraph>
                <paragraph>If you insist - yes its possible, but scripts that use this hack won’t be considered
                    for inclusion in Blender and any issues with using it won’t be considered bugs,
                    this is also not guaranteed to work in future releases.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)</literal_block>
            </section>
        </section>
        <section ids="modes-and-mesh-access" names="modes\ and\ mesh\ access">
            <title>Modes and Mesh Access</title>
            <paragraph>When working with mesh data you may run into the problem where a script fails to run as expected in edit-mode.
                This is caused by edit-mode having its own data which is only written back to the mesh when exiting edit-mode.</paragraph>
            <paragraph>A common example is that exporters may access a mesh through <literal>obj.data</literal> (a <reference internal="True" reftitle="bpy.types.Mesh" refuri="bpy.types.Mesh#bpy.types.Mesh"><literal classes="xref py py-class">bpy.types.Mesh</literal></reference>)
                but the user is in edit-mode, where the mesh data is available but out of sync with the edit mesh.</paragraph>
            <paragraph>In this situation you can…</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Exit edit-mode before running the tool.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Explicitly update the mesh by calling <reference internal="True" reftitle="bmesh.types.BMesh.to_mesh" refuri="bmesh.types#bmesh.types.BMesh.to_mesh"><literal classes="xref py py-class">bmesh.types.BMesh.to_mesh</literal></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Modify the script to support working on the edit-mode data directly, see: <reference internal="True" reftitle="bmesh.from_edit_mesh" refuri="bmesh#bmesh.from_edit_mesh"><literal classes="xref py py-mod">bmesh.from_edit_mesh</literal></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Report the context as incorrect and only allow the script to run outside edit-mode.</paragraph>
                </list_item>
            </bullet_list>
            <target refid="info-gotcha-mesh-faces"></target>
        </section>
        <section ids="n-gons-and-tessellation-faces info-gotcha-mesh-faces" names="n-gons\ and\ tessellation\ faces info_gotcha_mesh_faces">
            <title>N-Gons and Tessellation Faces</title>
            <paragraph>Since 2.63 NGons are supported, this adds some complexity
                since in some cases you need to access triangles/quads still (some exporters for example).</paragraph>
            <paragraph>There are now 3 ways to access faces:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" reftitle="bpy.types.MeshPolygon" refuri="bpy.types.MeshPolygon#bpy.types.MeshPolygon"><literal classes="xref py py-class">bpy.types.MeshPolygon</literal></reference> -
                        this is the data structure which now stores faces in object mode
                        (access as <literal>mesh.polygons</literal> rather than <literal>mesh.faces</literal>).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" reftitle="bpy.types.MeshTessFace" refuri="bpy.types.MeshTessFace#bpy.types.MeshTessFace"><literal classes="xref py py-class">bpy.types.MeshTessFace</literal></reference> -
                        the result of triangulating (tessellated) polygons,
                        the main method of face access in 2.62 or older (access as <literal>mesh.tessfaces</literal>).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" reftitle="bmesh.types.BMFace" refuri="bmesh.types#bmesh.types.BMFace"><literal classes="xref py py-class">bmesh.types.BMFace</literal></reference> -
                        the polygons as used in editmode.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>For the purpose of the following documentation,
                these will be referred to as polygons, tessfaces and bmesh-faces respectively.</paragraph>
            <paragraph>5+ sided faces will be referred to as <literal>ngons</literal>.</paragraph>
            <section ids="support-overview" names="support\ overview">
                <title>Support Overview</title>
                <table>
                    <tgroup cols="4">
                        <colspec colwidth="25" stub="1"></colspec>
                        <colspec colwidth="25"></colspec>
                        <colspec colwidth="25"></colspec>
                        <colspec colwidth="25"></colspec>
                        <thead>
                            <row>
                                <entry>
                                    <paragraph>Usage</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><reference internal="True" reftitle="bpy.types.MeshPolygon" refuri="bpy.types.MeshPolygon#bpy.types.MeshPolygon"><literal classes="xref py py-class">bpy.types.MeshPolygon</literal></reference></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><reference internal="True" reftitle="bpy.types.MeshTessFace" refuri="bpy.types.MeshTessFace#bpy.types.MeshTessFace"><literal classes="xref py py-class">bpy.types.MeshTessFace</literal></reference></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><reference internal="True" reftitle="bmesh.types.BMFace" refuri="bmesh.types#bmesh.types.BMFace"><literal classes="xref py py-class">bmesh.types.BMFace</literal></reference></paragraph>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph>Import/Create</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Poor <emphasis>(inflexible)</emphasis></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Good <emphasis>(supported as upgrade path)</emphasis></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Best</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>Manipulate</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Poor <emphasis>(inflexible)</emphasis></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Poor <emphasis>(loses ngons)</emphasis></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Best</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>Export/Output</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Good <emphasis>(ngon support)</emphasis></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Good <emphasis>(When ngons can’t be used)</emphasis></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Good <emphasis>(ngons, extra memory overhead)</emphasis></paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <note>
                    <paragraph>Using the <reference internal="True" reftitle="bmesh" refuri="bmesh#module-bmesh"><literal classes="xref py py-mod">bmesh</literal></reference> api is completely separate api from <reference internal="True" reftitle="bpy" refuri="bpy.data#module-bpy"><literal classes="xref py py-mod">bpy</literal></reference>,
                        typically you would would use one or the other based on the level of editing needed,
                        not simply for a different way to access faces.</paragraph>
                </note>
            </section>
            <section ids="creating" names="creating">
                <title>Creating</title>
                <paragraph>All 3 datatypes can be used for face creation.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>polygons are the most efficient way to create faces but the data structure is _very_ rigid and inflexible,
                            you must have all your vertes and faces ready and create them all at once.
                            This is further complicated by the fact that each polygon does not store its own verts (as with tessfaces),
                            rather they reference an index and size in <reference internal="True" reftitle="bpy.types.Mesh.loops" refuri="bpy.types.Mesh#bpy.types.Mesh.loops"><literal classes="xref py py-class">bpy.types.Mesh.loops</literal></reference> which are a fixed array too.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>tessfaces ideally should not be used for creating faces since they are really only tessellation cache of polygons,
                            however for scripts upgrading from 2.62 this is by far the most straightforward option.
                            This works by creating tessfaces and when finished -
                            they can be converted into polygons by calling <reference internal="True" reftitle="bpy.types.Mesh.update" refuri="bpy.types.Mesh#bpy.types.Mesh.update"><literal classes="xref py py-class">bpy.types.Mesh.update</literal></reference>.
                            The obvious limitation is ngons can’t be created this way.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>bmesh-faces are most likely the easiest way for new scripts to create faces,
                            since faces can be added one by one and the api has features intended for mesh manipulation.
                            While <reference internal="True" reftitle="bmesh.types.BMesh" refuri="bmesh.types#bmesh.types.BMesh"><literal classes="xref py py-class">bmesh.types.BMesh</literal></reference> uses more memory it can be managed by only operating on one mesh at a time.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="editing" names="editing">
                <title>Editing</title>
                <paragraph>Editing is where the 3 data types vary most.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Polygons are very limited for editing,
                            changing materials and options like smooth works but for anything else
                            they are too inflexible and are only intended for storage.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Tessfaces should not be used for editing geometry because doing so will cause existing ngons to be tessellated.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>BMesh-Faces are by far the best way to manipulate geometry.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="exporting" names="exporting">
                <title>Exporting</title>
                <paragraph>All 3 data types can be used for exporting,
                    the choice mostly depends on whether the target format supports ngons or not.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Polygons are the most direct &amp; efficient way to export providing they convert into the output format easily enough.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Tessfaces work well for exporting to formats which don’t support ngons,
                            in fact this is the only place where their use is encouraged.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>BMesh-Faces can work for exporting too but may not be necessary if polygons can be used
                            since using bmesh gives some overhead because its not the native storage format in object mode.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="upgrading-importers-from-2-62" names="upgrading\ importers\ from\ 2.62">
                <title>Upgrading Importers from 2.62</title>
                <paragraph>Importers can be upgraded to work with only minor changes.</paragraph>
                <paragraph>The main change to be made is used the tessellation versions of each attribute.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>mesh.faces –&gt; <reference internal="True" reftitle="bpy.types.Mesh.tessfaces" refuri="bpy.types.Mesh#bpy.types.Mesh.tessfaces"><literal classes="xref py py-class">bpy.types.Mesh.tessfaces</literal></reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>mesh.uv_textures –&gt; <reference internal="True" reftitle="bpy.types.Mesh.tessface_uv_textures" refuri="bpy.types.Mesh#bpy.types.Mesh.tessface_uv_textures"><literal classes="xref py py-class">bpy.types.Mesh.tessface_uv_textures</literal></reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>mesh.vertex_colors –&gt; <reference internal="True" reftitle="bpy.types.Mesh.tessface_vertex_colors" refuri="bpy.types.Mesh#bpy.types.Mesh.tessface_vertex_colors"><literal classes="xref py py-class">bpy.types.Mesh.tessface_vertex_colors</literal></reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Once the data is created call <reference internal="True" reftitle="bpy.types.Mesh.update" refuri="bpy.types.Mesh#bpy.types.Mesh.update"><literal classes="xref py py-class">bpy.types.Mesh.update</literal></reference> to convert the tessfaces into polygons.</paragraph>
            </section>
            <section ids="upgrading-exporters-from-2-62" names="upgrading\ exporters\ from\ 2.62">
                <title>Upgrading Exporters from 2.62</title>
                <paragraph>For exporters the most direct way to upgrade is to use tessfaces as with importing
                    however its important to know that tessfaces may <strong>not</strong> exist for a mesh,
                    the array will be empty as if there are no faces.</paragraph>
                <paragraph>So before accessing tessface data call: <reference internal="True" reftitle="bpy.types.Mesh.update" refuri="bpy.types.Mesh#bpy.types.Mesh.update"><literal classes="xref py py-class">bpy.types.Mesh.update</literal></reference> <literal>(calc_tessface=True)</literal>.</paragraph>
            </section>
        </section>
        <section ids="editbones-posebones-bone-bones" names="editbones,\ posebones,\ bone...\ bones">
            <title>EditBones, PoseBones, Bone… Bones</title>
            <paragraph>Armature Bones in Blender have three distinct data structures that contain them.
                If you are accessing the bones through one of them, you may not have access to the properties you really need.</paragraph>
            <note>
                <paragraph>In the following examples <literal>bpy.context.object</literal> is assumed to be an armature object.</paragraph>
            </note>
            <section ids="edit-bones" names="edit\ bones">
                <title>Edit Bones</title>
                <paragraph><literal>bpy.context.object.data.edit_bones</literal> contains a editbones;
                    to access them you must set the armature mode to edit mode first (editbones do not exist in object or pose mode).
                    Use these to create new bones, set their head/tail or roll, change their parenting relationships to other bones, etc.</paragraph>
                <paragraph>Example using <reference internal="True" reftitle="bpy.types.EditBone" refuri="bpy.types.EditBone#bpy.types.EditBone"><literal classes="xref py py-class">bpy.types.EditBone</literal></reference> in armature editmode:</paragraph>
                <paragraph>This is only possible in edit mode.</paragraph>
                <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.context.object.data.edit_bones["Bone"].head = Vector((1.0, 2.0, 3.0))</doctest_block>
                <paragraph>This will be empty outside of editmode.</paragraph>
                <doctest_block xml:space="preserve">&gt;&gt;&gt; mybones = bpy.context.selected_editable_bones</doctest_block>
                <paragraph>Returns an editbone only in edit mode.</paragraph>
                <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.context.active_bone</doctest_block>
            </section>
            <section ids="bones-object-mode" names="bones\ (object\ mode)">
                <title>Bones (Object Mode)</title>
                <paragraph><literal>bpy.context.object.data.bones</literal> contains bones.
                    These <emphasis>live</emphasis> in object mode, and have various properties you can change,
                    note that the head and tail properties are read-only.</paragraph>
                <paragraph>Example using <reference internal="True" reftitle="bpy.types.Bone" refuri="bpy.types.Bone#bpy.types.Bone"><literal classes="xref py py-class">bpy.types.Bone</literal></reference> in object or pose mode:</paragraph>
                <paragraph>Returns a bone (not an editbone) outside of edit mode</paragraph>
                <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.context.active_bone</doctest_block>
                <paragraph>This works, as with blender the setting can be edited in any mode</paragraph>
                <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.context.object.data.bones["Bone"].use_deform = True</doctest_block>
                <paragraph>Accessible but read-only</paragraph>
                <doctest_block xml:space="preserve">&gt;&gt;&gt; tail = myobj.data.bones["Bone"].tail</doctest_block>
            </section>
            <section ids="pose-bones" names="pose\ bones">
                <title>Pose Bones</title>
                <paragraph><literal>bpy.context.object.pose.bones</literal> contains pose bones.
                    This is where animation data resides, i.e. animatable transformations
                    are applied to pose bones, as are constraints and ik-settings.</paragraph>
                <paragraph>Examples using <reference internal="True" reftitle="bpy.types.PoseBone" refuri="bpy.types.PoseBone#bpy.types.PoseBone"><literal classes="xref py py-class">bpy.types.PoseBone</literal></reference> in object or pose mode:</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Gets the name of the first constraint (if it exists)
bpy.context.object.pose.bones["Bone"].constraints[0].name

# Gets the last selected pose bone (pose mode only)
bpy.context.active_pose_bone</literal_block>
                <note>
                    <paragraph>Notice the pose is accessed from the object rather than the object data,
                        this is why blender can have 2 or more objects sharing the same armature in different poses.</paragraph>
                </note>
                <note>
                    <paragraph>Strictly speaking PoseBone’s are not bones, they are just the state of the armature,
                        stored in the <reference internal="True" reftitle="bpy.types.Object" refuri="bpy.types.Object#bpy.types.Object"><literal classes="xref py py-class">bpy.types.Object</literal></reference> rather than the <reference internal="True" reftitle="bpy.types.Armature" refuri="bpy.types.Armature#bpy.types.Armature"><literal classes="xref py py-class">bpy.types.Armature</literal></reference>,
                        the real bones are however accessible from the pose bones - <reference internal="True" reftitle="bpy.types.PoseBone.bone" refuri="bpy.types.PoseBone#bpy.types.PoseBone.bone"><literal classes="xref py py-class">bpy.types.PoseBone.bone</literal></reference></paragraph>
                </note>
            </section>
            <section ids="armature-mode-switching" names="armature\ mode\ switching">
                <title>Armature Mode Switching</title>
                <paragraph>While writing scripts that deal with armatures you may find you have to switch between modes,
                    when doing so take care when switching out of edit-mode not to keep references
                    to the edit-bones or their head/tail vectors.
                    Further access to these will crash blender so its important the script
                    clearly separates sections of the code which operate in different modes.</paragraph>
                <paragraph>This is mainly an issue with editmode since pose data can be manipulated without having to be in pose mode,
                    however for operator access you may still need to enter pose mode.</paragraph>
            </section>
        </section>
        <section ids="data-names" names="data\ names">
            <title>Data Names</title>
            <section ids="naming-limitations" names="naming\ limitations">
                <title>Naming Limitations</title>
                <paragraph>A common mistake is to assume newly created data is given the requested name.</paragraph>
                <paragraph>This can cause bugs when you add some data (normally imported) then reference it later by name.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.data.meshes.new(name=meshid)

# normally some code, function calls...
bpy.data.meshes[meshid]</literal_block>
                <paragraph>Or with name assignment…</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">obj.name = objname

# normally some code, function calls...
obj = bpy.data.meshes[objname]</literal_block>
                <paragraph>Data names may not match the assigned values if they exceed the maximum length, are already used or an empty string.</paragraph>
                <paragraph>Its better practice not to reference objects by names at all,
                    once created you can store the data in a list, dictionary, on a class etc,
                    there is rarely a reason to have to keep searching for the same data by name.</paragraph>
                <paragraph>If you do need to use name references, its best to use a dictionary to maintain
                    a mapping between the names of the imported assets and the newly created data,
                    this way you don’t run this risk of referencing existing data from the blend file, or worse modifying it.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve"># typically declared in the main body of the function.
mesh_name_mapping = {}

mesh = bpy.data.meshes.new(name=meshid)
mesh_name_mapping[meshid] = mesh

# normally some code, or function calls...

# use own dictionary rather than bpy.data
mesh = mesh_name_mapping[meshid]</literal_block>
            </section>
            <section ids="library-collisions" names="library\ collisions">
                <title>Library Collisions</title>
                <paragraph>Blender keeps data names unique - <reference internal="True" reftitle="bpy.types.ID.name" refuri="bpy.types.ID#bpy.types.ID.name"><literal classes="xref py py-class">bpy.types.ID.name</literal></reference> so you can’t name two objects,
                    meshes, scenes etc the same thing by accident.</paragraph>
                <paragraph>However when linking in library data from another blend file naming collisions can occur,
                    so its best to avoid referencing data by name at all.</paragraph>
                <paragraph>This can be tricky at times and not even blender handles this correctly in some case
                    (when selecting the modifier object for eg you can’t select between multiple objects with the same name),
                    but its still good to try avoid problems in this area.</paragraph>
                <paragraph>If you need to select between local and library data, there is a feature in <literal>bpy.data</literal> members to allow for this.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve"># typical name lookup, could be local or library.
obj = bpy.data.objects["my_obj"]

# library object name look up using a pair
# where the second argument is the library path matching bpy.types.Library.filepath
obj = bpy.data.objects["my_obj", "//my_lib.blend"]

# local object name look up using a pair
# where the second argument excludes library data from being returned.
obj = bpy.data.objects["my_obj", None]

# both the examples above also works for 'get'
obj = bpy.data.objects.get(("my_obj", None))</literal_block>
            </section>
        </section>
        <section ids="relative-file-paths" names="relative\ file\ paths">
            <title>Relative File Paths</title>
            <paragraph>Blenders relative file paths are not compatible with standard Python modules such as <literal>sys</literal> and <literal>os</literal>.</paragraph>
            <paragraph>Built in Python functions don’t understand blenders <literal>//</literal> prefix which denotes the blend file path.</paragraph>
            <paragraph>A common case where you would run into this problem is when exporting a material with associated image paths.</paragraph>
            <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.path.abspath(image.filepath)</doctest_block>
            <paragraph>When using blender data from linked libraries there is an unfortunate complication
                since the path will be relative to the library rather than the open blend file.
                When the data block may be from an external blend file pass the library argument from the <reference internal="True" reftitle="bpy.types.ID" refuri="bpy.types.ID#bpy.types.ID"><literal classes="xref py py-class">bpy.types.ID</literal></reference>.</paragraph>
            <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.path.abspath(image.filepath, library=image.library)</doctest_block>
            <paragraph>These returns the absolute path which can be used with native Python modules.</paragraph>
        </section>
        <section ids="unicode-problems" names="unicode\ problems">
            <title>Unicode Problems</title>
            <paragraph>Python supports many different encodings so there is nothing stopping you from
                writing a script in <literal>latin1</literal> or <literal>iso-8859-15</literal>.</paragraph>
            <paragraph>See <reference name="pep-0263" refuri="https://www.python.org/dev/peps/pep-0263/">pep-0263</reference><target ids="pep-0263" names="pep-0263" refuri="https://www.python.org/dev/peps/pep-0263/"></target></paragraph>
            <paragraph>However this complicates matters for Blender’s Python API because <literal>.blend</literal> files don’t have an explicit encoding.</paragraph>
            <paragraph>To avoid the problem for Python integration and script authors we have decided all strings in blend files
                <strong>must</strong> be <literal>UTF-8</literal>, <literal>ASCII</literal> compatible.</paragraph>
            <paragraph>This means assigning strings with different encodings to an object names for instance will raise an error.</paragraph>
            <paragraph>Paths are an exception to this rule since we cannot ignore the existence of non <literal>UTF-8</literal> paths on users file-system.</paragraph>
            <paragraph>This means seemingly harmless expressions can raise errors, eg.</paragraph>
            <doctest_block xml:space="preserve">&gt;&gt;&gt; print(bpy.data.filepath)
UnicodeEncodeError: 'ascii' codec can't encode characters in position 10-21: ordinal not in range(128)</doctest_block>
            <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.context.object.name = bpy.data.filepath
Traceback (most recent call last):
  File "&lt;blender_console&gt;", line 1, in &lt;module&gt;
TypeError: bpy_struct: item.attr= val: Object.name expected a string type, not str</doctest_block>
            <paragraph>Here are 2 ways around filesystem encoding issues:</paragraph>
            <doctest_block xml:space="preserve">&gt;&gt;&gt; print(repr(bpy.data.filepath))</doctest_block>
            <doctest_block xml:space="preserve">&gt;&gt;&gt; import os
&gt;&gt;&gt; filepath_bytes = os.fsencode(bpy.data.filepath)
&gt;&gt;&gt; filepath_utf8 = filepath_bytes.decode('utf-8', "replace")
&gt;&gt;&gt; bpy.context.object.name = filepath_utf8</doctest_block>
            <paragraph>Unicode encoding/decoding is a big topic with comprehensive Python documentation,
                to avoid getting stuck too deep in encoding problems - here are some suggestions:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Always use utf-8 encoding or convert to utf-8 where the input is unknown.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Avoid manipulating filepaths as strings directly, use <literal>os.path</literal> functions instead.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Use <literal>os.fsencode()</literal> / <literal>os.fsdecode()</literal> instead of built in string decoding functions when operating on paths.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>To print paths or to include them in the user interface use <literal>repr(path)</literal> first
                        or <literal>"%r" % path</literal> with string formatting.</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>Sometimes it’s preferable to avoid string encoding issues by using bytes instead of Python strings,
                    when reading some input its less trouble to read it as binary data
                    though you will still need to decide how to treat any strings you want to use with Blender,
                    some importers do this.</paragraph>
            </note>
        </section>
        <section ids="strange-errors-using-threading-module" names="strange\ errors\ using\ 'threading'\ module">
            <title>Strange errors using ‘threading’ module</title>
            <paragraph>Python threading with Blender only works properly when the threads finish up before the script does.
                By using <literal>threading.join()</literal> for example.</paragraph>
            <paragraph>Heres an example of threading supported by Blender:</paragraph>
            <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">import threading
import time

def prod():
    print(threading.current_thread().name, "Starting")

    # do something vaguely useful
    import bpy
    from mathutils import Vector
    from random import random

    prod_vec = Vector((random() - 0.5, random() - 0.5, random() - 0.5))
    print("Prodding", prod_vec)
    bpy.data.objects["Cube"].location += prod_vec
    time.sleep(random() + 1.0)
    # finish

    print(threading.current_thread().name, "Exiting")

threads = [threading.Thread(name="Prod %d" % i, target=prod) for i in range(10)]


print("Starting threads...")

for t in threads:
    t.start()

print("Waiting for threads to finish...")

for t in threads:
    t.join()</literal_block>
            <paragraph>This an example of a timer which runs many times a second and moves
                the default cube continuously while Blender runs <strong>(Unsupported)</strong>.</paragraph>
            <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">def func():
    print("Running...")
    import bpy
    bpy.data.objects['Cube'].location.x += 0.05

def my_timer():
    from threading import Timer
    t = Timer(0.1, my_timer)
    t.start()
    func()

my_timer()</literal_block>
            <paragraph>Use cases like the one above which leave the thread running once the script finishes
                may seem to work for a while but end up causing random crashes or errors in Blender’s own drawing code.</paragraph>
            <paragraph>So far, no work has gone into making Blender’s Python integration thread safe,
                so until its properly supported, best not make use of this.</paragraph>
            <note>
                <paragraph>Pythons threads only allow co-currency and won’t speed up your scripts on multi-processor systems,
                    the <literal>subprocess</literal> and <literal>multiprocess</literal> modules can be used with Blender and make use of multiple CPU’s too.</paragraph>
            </note>
        </section>
        <section ids="help-my-script-crashes-blender" names="help!\ my\ script\ crashes\ blender">
            <title>Help! My script crashes Blender</title>
            <paragraph>Ideally it would be impossible to crash Blender from Python
                however there are some problems with the API where it can be made to crash.</paragraph>
            <paragraph>Strictly speaking this is a bug in the API but fixing it would mean adding memory verification
                on every access since most crashes are caused by the Python objects referencing Blenders memory directly,
                whenever the memory is freed, further Python access to it can crash the script.
                But fixing this would make the scripts run very slow,
                or writing a very different kind of API which doesn’t reference the memory directly.</paragraph>
            <paragraph>Here are some general hints to avoid running into these problems.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Be aware of memory limits,
                        especially when working with large lists since Blender can crash simply by running out of memory.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Many hard to fix crashes end up being because of referencing freed data,
                        when removing data be sure not to hold any references to it.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Modules or classes that remain active while Blender is used,
                        should not hold references to data the user may remove, instead,
                        fetch data from the context each time the script is activated.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Crashes may not happen every time, they may happen more on some configurations/operating-systems.</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>To find the line of your script that crashes you can use the <literal>faulthandler</literal> module.
                    See the <reference name="faulthandler docs" refuri="https://docs.python.org/dev/library/faulthandler.html">faulthandler docs</reference><target ids="faulthandler-docs" names="faulthandler\ docs" refuri="https://docs.python.org/dev/library/faulthandler.html"></target>.</paragraph>
                <paragraph>While the crash may be in Blenders C/C++ code,
                    this can help a lot to track down the area of the script that causes the crash.</paragraph>
            </note>
            <section ids="undo-redo" names="undo/redo">
                <title>Undo/Redo</title>
                <paragraph>Undo invalidates all <reference internal="True" reftitle="bpy.types.ID" refuri="bpy.types.ID#bpy.types.ID"><literal classes="xref py py-class">bpy.types.ID</literal></reference> instances (Object, Scene, Mesh, Lamp… etc).</paragraph>
                <paragraph>This example shows how you can tell undo changes the memory locations.</paragraph>
                <block_quote>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; hash(bpy.context.object)
-9223372036849950810
&gt;&gt;&gt; hash(bpy.context.object)
-9223372036849950810</doctest_block>
                    <paragraph># … move the active object, then undo</paragraph>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; hash(bpy.context.object)
-9223372036849951740</doctest_block>
                </block_quote>
                <paragraph>As suggested above, simply not holding references to data when Blender is used
                    interactively by the user is the only way to ensure the script doesn’t become unstable.</paragraph>
                <section ids="undo-library-data" names="undo\ &amp;\ library\ data">
                    <title>Undo &amp; Library Data</title>
                    <paragraph>One of the advantages with Blenders library linking system that undo
                        can skip checking changes in library data since it is assumed to be static.</paragraph>
                    <paragraph>Tools in Blender are not allowed to modify library data.</paragraph>
                    <paragraph>Python however does not enforce this restriction.</paragraph>
                    <paragraph>This can be useful in some cases, using a script to adjust material values for example.
                        But its also possible to use a script to make library data point to newly created local data,
                        which is not supported since a call to undo will remove the local data
                        but leave the library referencing it and likely crash.</paragraph>
                    <paragraph>So it’s best to consider modifying library data an advanced usage of the API
                        and only to use it when you know what you’re doing.</paragraph>
                </section>
            </section>
            <section ids="edit-mode-memory-access" names="edit\ mode\ /\ memory\ access">
                <title>Edit Mode / Memory Access</title>
                <paragraph>Switching edit-mode <literal>bpy.ops.object.mode_set(mode='EDIT')</literal> / <literal>bpy.ops.object.mode_set(mode='OBJECT')</literal>
                    will re-allocate objects data,
                    any references to a meshes vertices/polygons/uvs, armatures bones,
                    curves points etc cannot be accessed after switching edit-mode.</paragraph>
                <paragraph>Only the reference to the data its self can be re-accessed, the following example will crash.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">mesh = bpy.context.active_object.data
polygons = mesh.polygons
bpy.ops.object.mode_set(mode='EDIT')
bpy.ops.object.mode_set(mode='OBJECT')

# this will crash
print(polygons)</literal_block>
                <paragraph>So after switching edit-mode you need to re-access any object data variables,
                    the following example shows how to avoid the crash above.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">mesh = bpy.context.active_object.data
polygons = mesh.polygons
bpy.ops.object.mode_set(mode='EDIT')
bpy.ops.object.mode_set(mode='OBJECT')

# polygons have been re-allocated
polygons = mesh.polygons
print(polygons)</literal_block>
                <paragraph>These kinds of problems can happen for any functions which re-allocate
                    the object data but are most common when switching edit-mode.</paragraph>
            </section>
            <section ids="array-re-allocation" names="array\ re-allocation">
                <title>Array Re-Allocation</title>
                <paragraph>When adding new points to a curve or vertices’s/edges/polygons to a mesh,
                    internally the array which stores this data is re-allocated.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">bpy.ops.curve.primitive_bezier_curve_add()
point = bpy.context.object.data.splines[0].bezier_points[0]
bpy.context.object.data.splines[0].bezier_points.add()

# this will crash!
point.co = 1.0, 2.0, 3.0</literal_block>
                <paragraph>This can be avoided by re-assigning the point variables after adding the new one or by storing
                    indices’s to the points rather than the points themselves.</paragraph>
                <paragraph>The best way is to sidestep the problem altogether add all the points to the curve at once.
                    This means you don’t have to worry about array re-allocation and its faster too
                    since reallocating the entire array for every point added is inefficient.</paragraph>
            </section>
            <section ids="removing-data" names="removing\ data">
                <title>Removing Data</title>
                <paragraph><strong>Any</strong> data that you remove shouldn’t be modified or accessed afterwards,
                    this includes f-curves, drivers, render layers, timeline markers, modifiers, constraints
                    along with objects, scenes, groups, bones.. etc.</paragraph>
                <paragraph>The <literal>remove()</literal> api calls will invalidate the data they free to prevent common mistakes.</paragraph>
                <paragraph>The following example shows how this precortion works.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">mesh = bpy.data.meshes.new(name="MyMesh")
# normally the script would use the mesh here...
bpy.data.meshes.remove(mesh)
print(mesh.name)  # &lt;- give an exception rather than crashing:

# ReferenceError: StructRNA of type Mesh has been removed</literal_block>
                <paragraph>But take care because this is limited to scripts accessing the variable which is removed,
                    the next example will still crash.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">mesh = bpy.data.meshes.new(name="MyMesh")
vertices = mesh.vertices
bpy.data.meshes.remove(mesh)
print(vertices)  # &lt;- this may crash</literal_block>
            </section>
        </section>
        <section ids="sys-exit" names="sys.exit">
            <title>sys.exit</title>
            <paragraph>Some Python modules will call <literal>sys.exit()</literal> themselves when an error occurs,
                while not common behavior this is something to watch out for because it may seem
                as if Blender is crashing since <literal>sys.exit()</literal> will close Blender immediately.</paragraph>
            <paragraph>For example, the <literal>argparse</literal> module will print an error and exit if the arguments are invalid.</paragraph>
            <paragraph>An ugly way of troubleshooting this is to set <literal>sys.exit = None</literal> and see what line of Python code is quitting,
                you could of course replace <literal>sys.exit</literal> with your own function but manipulating Python in this way is bad practice.</paragraph>
        </section>
    </section>
</document>
