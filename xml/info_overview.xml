<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/media/rou/Seagate Expansion Drive/Programming_Projects/Linux2018/Tests/blender/doc/python_api/sphinx-in/info_overview.rst">
    <target refid="info-overview"></target>
    <section ids="python-api-overview info-overview" names="python\ api\ overview info_overview">
        <title>Python API Overview</title>
        <paragraph>The purpose of this document is to explain how Python and Blender fit together,
            covering some of the functionality that may not be obvious from reading the API
            references and example scripts.</paragraph>
        <section ids="python-in-blender" names="python\ in\ blender">
            <title>Python in Blender</title>
            <paragraph>Blender has an embedded Python interpreter which is loaded when Blender is started and stays
                active while Blender is running. This interpreter runs scripts to draw the user interface
                and is used for some of Blender’s internal tools as well.</paragraph>
            <paragraph>Blender’s embedded interpreter provides a typical Python environment, so code from tutorials
                on how to write Python scripts can also be run with Blender’s interpreter. Blender provides its
                Python modules, such as <reference internal="True" reftitle="bpy" refuri="bpy.data#module-bpy"><literal classes="xref py py-mod">bpy</literal></reference> and <reference internal="True" reftitle="mathutils" refuri="mathutils#module-mathutils"><literal classes="xref py py-mod">mathutils</literal></reference>, to the embedded interpreter so they can
                be imported into a script and give access to Blender’s data, classes, and functions. Scripts that
                deal with Blender data will need to import the modules to work.</paragraph>
            <paragraph>Here is a simple example which moves a vertex attached to an object named <strong>Cube</strong>:</paragraph>
            <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">import bpy
bpy.data.objects["Cube"].data.vertices[0].co.x += 1.0</literal_block>
            <paragraph>This modifies Blender’s internal data directly.
                When you run this in the interactive console you will see the 3D viewport update.</paragraph>
        </section>
        <section ids="the-default-environment" names="the\ default\ environment">
            <title>The Default Environment</title>
            <paragraph>When developing your own scripts it may help to understand how Blender sets up its Python environment.
                Many Python scripts come bundled with Blender and can be used as a reference
                because they use the same API that script authors write tools in.
                Typical usage for scripts include: user interface, import/export,
                scene manipulation, automation, defining your own toolset and customization.</paragraph>
            <paragraph>On startup Blender scans the <literal>scripts/startup/</literal> directory for Python modules and imports them.
                The exact location of this directory depends on your installation.
                See the <inline classes="xref std std-ref">directory layout docs</inline>.</paragraph>
        </section>
        <section ids="script-loading" names="script\ loading">
            <title>Script Loading</title>
            <paragraph>This may seem obvious, but it is important to note the difference between
                executing a script directly and importing a script as a module.</paragraph>
            <paragraph>Extending Blender by executing a script directly means the classes that the script
                defines remain available inside Blender after the script finishes execution.
                Using scripts this way makes future access to their classes
                (to unregister them for example) more difficult compared to importing the scripts as modules.
                When a script is imported as a module, its class instances will remain
                inside the module and can be accessed later on by importing that module again.</paragraph>
            <paragraph>For this reason it is preferable to avoid directly executing scripts that extend Blender by registering classes.</paragraph>
            <paragraph>Here are some ways to run scripts directly in Blender.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Loaded in the text editor and press <strong>Run Script</strong>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Typed or pasted into the interactive console.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Execute a Python file from the command line with Blender, eg:</paragraph>
                    <literal_block highlight_args="{}" language="sh" linenos="False" xml:space="preserve">blender --python /home/me/my_script.py</literal_block>
                </list_item>
            </bullet_list>
            <paragraph>To run as modules:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The obvious way, <literal>import some_module</literal> command from the text window or interactive console.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Open as a text block and tick “Register” option, this will load with the blend file.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>copy into one of the directories <literal>scripts/startup</literal>, where they will be automatically imported on startup.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>define as an add-on, enabling the add-on will load it as a Python module.</paragraph>
                </list_item>
            </bullet_list>
            <section ids="add-ons" names="add-ons">
                <title>Add-ons</title>
                <paragraph>Some of Blenders functionality is best kept optional,
                    alongside scripts loaded at startup we have add-ons which are kept in their own directory <literal>scripts/addons</literal>,
                    and only load on startup if selected from the user preferences.</paragraph>
                <paragraph>The only difference between add-ons and built-in Python modules is that add-ons must contain a <literal>bl_info</literal>
                    variable which Blender uses to read metadata such as name, author, category and URL.</paragraph>
                <paragraph>The User Preferences add-on listing uses <strong>bl_info</strong> to display information about each add-on.</paragraph>
                <paragraph><reference name="See Add-ons" refuri="https://wiki.blender.org/index.php/Dev:Py/Scripts/Guidelines/Addons">See Add-ons</reference>
                    for details on the <literal>bl_info</literal> dictionary.</paragraph>
            </section>
        </section>
        <section ids="integration-through-classes" names="integration\ through\ classes">
            <title>Integration through Classes</title>
            <paragraph>Running Python scripts in the text editor is useful for testing but you’ll
                want to extend Blender to make tools accessible like other built-in functionality.</paragraph>
            <paragraph>The Blender Python api allows integration for:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" reftitle="bpy.types.Panel" refuri="bpy.types.Panel#bpy.types.Panel"><literal classes="xref py py-class">bpy.types.Panel</literal></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" reftitle="bpy.types.Menu" refuri="bpy.types.Menu#bpy.types.Menu"><literal classes="xref py py-class">bpy.types.Menu</literal></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" reftitle="bpy.types.Operator" refuri="bpy.types.Operator#bpy.types.Operator"><literal classes="xref py py-class">bpy.types.Operator</literal></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" reftitle="bpy.types.PropertyGroup" refuri="bpy.types.PropertyGroup#bpy.types.PropertyGroup"><literal classes="xref py py-class">bpy.types.PropertyGroup</literal></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" reftitle="bpy.types.KeyingSet" refuri="bpy.types.KeyingSet#bpy.types.KeyingSet"><literal classes="xref py py-class">bpy.types.KeyingSet</literal></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" reftitle="bpy.types.RenderEngine" refuri="bpy.types.RenderEngine#bpy.types.RenderEngine"><literal classes="xref py py-class">bpy.types.RenderEngine</literal></reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>This is intentionally limited. Currently, for more advanced features such as mesh modifiers,
                object types, or shader nodes, C/C++ must be used.</paragraph>
            <paragraph>For Python integration Blender defines methods which are common to all types.
                This works by creating a Python subclass of a Blender class which contains variables and functions
                specified by the parent class which are pre-defined to interface with Blender.</paragraph>
            <paragraph>For example:</paragraph>
            <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">import bpy
class SimpleOperator(bpy.types.Operator):
    bl_idname = "object.simple_operator"
    bl_label = "Tool Name"

    def execute(self, context):
        print("Hello World")
        return {'FINISHED'}

bpy.utils.register_class(SimpleOperator)</literal_block>
            <paragraph>First note that we subclass a member of <reference internal="True" reftitle="bpy.types" refuri="bpy.types.wmTools#module-bpy.types"><literal classes="xref py py-mod">bpy.types</literal></reference>,
                this is common for all classes which can be integrated with Blender and
                used so we know if this is an Operator and not a Panel when registering.</paragraph>
            <paragraph>Both class properties start with a <literal>bl_</literal> prefix.
                This is a convention used to distinguish Blender properties from those you add yourself.</paragraph>
            <paragraph>Next see the execute function, which takes an instance of the operator and the current context.
                A common prefix is not used for functions.</paragraph>
            <paragraph>Lastly the register function is called, this takes the class and loads it into Blender. See <reference name="Class Registration" refid="class-registration">Class Registration</reference>.</paragraph>
            <paragraph>Regarding inheritance, Blender doesn’t impose restrictions on the kinds of class inheritance used,
                the registration checks will use attributes and functions defined in parent classes.</paragraph>
            <paragraph>class mix-in example:</paragraph>
            <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">import bpy
class BaseOperator:
    def execute(self, context):
        print("Hello World BaseClass")
        return {'FINISHED'}

class SimpleOperator(bpy.types.Operator, BaseOperator):
    bl_idname = "object.simple_operator"
    bl_label = "Tool Name"

bpy.utils.register_class(SimpleOperator)</literal_block>
            <paragraph>Notice these classes don’t define an <literal>__init__(self)</literal> function.
                While <literal>__init__()</literal> and <literal>__del__()</literal> will be called if defined,
                the class instances lifetime only spans the execution.
                So a panel for example will have a new instance for every redraw,
                for this reason there is rarely a cause to store variables in the panel instance.
                Instead, persistent variables should be stored in Blenders
                ata so that the state can be restored when Blender is restarted.</paragraph>
            <note>
                <paragraph>Modal operators are an exception, keeping their instance variable as Blender runs, see modal operator template.</paragraph>
            </note>
            <paragraph>So once the class is registered with Blender, instancing the class and calling the functions is left up to Blender.
                In fact you cannot instance these classes from the script as you would expect with most Python API’s.</paragraph>
            <paragraph>To run operators you can call them through the operator api, eg:</paragraph>
            <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">import bpy
bpy.ops.object.simple_operator()</literal_block>
            <paragraph>User interface classes are given a context in which to draw, buttons window, file header, toolbar etc,
                then they are drawn when that area is displayed so they are never called by Python scripts directly.</paragraph>
            <target refid="info-overview-registration"></target>
        </section>
        <section ids="registration info-overview-registration" names="registration info_overview_registration">
            <title>Registration</title>
            <section ids="module-registration" names="module\ registration">
                <title>Module Registration</title>
                <paragraph>Blender modules loaded at startup require <literal>register()</literal> and <literal>unregister()</literal> functions.
                    These are the <emphasis>only</emphasis> functions that Blender calls from your code, which is otherwise a regular Python module.</paragraph>
                <paragraph>A simple Blender/Python module can look like this:</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">import bpy

class SimpleOperator(bpy.types.Operator):
    """ See example above """

def register():
    bpy.utils.register_class(SimpleOperator)

def unregister():
    bpy.utils.unregister_class(SimpleOperator)

if __name__ == "__main__":
    register()</literal_block>
                <paragraph>These functions usually appear at the bottom of the script containing class registration sometimes adding menu items.
                    You can also use them for internal purposes setting up data for your own tools but take care
                    since register won’t re-run when a new blend file is loaded.</paragraph>
                <paragraph>The register/unregister calls are used so it’s possible to toggle add-ons and reload scripts while Blender runs.
                    If the register calls were placed in the body of the script, registration would be called on import,
                    meaning there would be no distinction between importing a module or loading its classes into Blender.</paragraph>
                <paragraph>This becomes problematic when a script imports classes from another module
                    making it difficult to manage which classes are being loaded and when.</paragraph>
                <paragraph>The last 2 lines are only for testing:</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">if __name__ == "__main__":
    register()</literal_block>
                <paragraph>This allows the script to be run directly in the text editor to test changes.
                    This <literal>register()</literal> call won’t run when the script is imported as a module
                    since <literal>__main__</literal> is reserved for direct execution.</paragraph>
            </section>
            <section ids="class-registration" names="class\ registration">
                <title>Class Registration</title>
                <paragraph>Registering a class with Blender results in the class definition being loaded into Blender,
                    where it becomes available alongside existing functionality.</paragraph>
                <paragraph>Once this class is loaded you can access it from <reference internal="True" reftitle="bpy.types" refuri="bpy.types.wmTools#module-bpy.types"><literal classes="xref py py-mod">bpy.types</literal></reference>,
                    using the bl_idname rather than the classes original name.</paragraph>
                <paragraph>When loading a class, Blender performs sanity checks making sure all required properties and functions are found,
                    that properties have the correct type, and that functions have the right number of arguments.</paragraph>
                <paragraph>Mostly you will not need concern yourself with this but if there is a problem
                    with the class definition it will be raised on registering:</paragraph>
                <paragraph>Using the function arguments <literal>def execute(self, context, spam)</literal>, will raise an exception:</paragraph>
                <paragraph><literal>ValueError: expected Operator, SimpleOperator class "execute" function to have 2 args, found 3</literal></paragraph>
                <paragraph>Using <literal>bl_idname = 1</literal> will raise.</paragraph>
                <paragraph><literal>TypeError: validating class error: Operator.bl_idname expected a string type, not int</literal></paragraph>
                <section ids="multiple-classes" names="multiple-classes">
                    <title>Multiple-Classes</title>
                    <paragraph>Loading classes into Blender is described above,
                        for simple cases calling <reference internal="True" reftitle="bpy.utils.register_class" refuri="bpy.utils#bpy.utils.register_class"><literal classes="xref py py-mod">bpy.utils.register_class</literal></reference> (SomeClass) is sufficient,
                        but when there are many classes or a packages submodule has its own
                        classes it can be tedious to list them all for registration.</paragraph>
                    <paragraph>For more convenient loading/unloading <literal classes="xref py py-mod">bpy.utils.register_module</literal> (module)
                        and <literal classes="xref py py-mod">bpy.utils.unregister_module</literal> (module) functions exist.</paragraph>
                    <paragraph>A script which defines many of its own operators, panels menus etc. you only need to write:</paragraph>
                    <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">def register():
    bpy.utils.register_module(__name__)

def unregister():
    bpy.utils.unregister_module(__name__)</literal_block>
                    <paragraph>Internally Blender collects subclasses on registrable types, storing them by the module in which they are defined.
                        By passing the module name to <literal classes="xref py py-mod">bpy.utils.register_module</literal>
                        Blender can register all classes created by this module and its submodules.</paragraph>
                </section>
                <section ids="inter-classes-dependencies" names="inter\ classes\ dependencies">
                    <title>Inter Classes Dependencies</title>
                    <paragraph>When customizing Blender you may want to group your own settings together,
                        after all, they will likely have to co-exist with other scripts.
                        To group these properties classes need to be defined,
                        for groups within groups or collections within groups
                        you can find yourself having to deal with order of registration/unregistration.</paragraph>
                    <paragraph>Custom properties groups are themselves classes which need to be registered.</paragraph>
                    <paragraph>Say you want to store material settings for a custom engine.</paragraph>
                    <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Create new property
# bpy.data.materials[0].my_custom_props.my_float
import bpy

class MyMaterialProps(bpy.types.PropertyGroup):
    my_float = bpy.props.FloatProperty()

def register():
    bpy.utils.register_class(MyMaterialProps)
    bpy.types.Material.my_custom_props = bpy.props.PointerProperty(type=MyMaterialProps)

def unregister():
    del bpy.types.Material.my_custom_props
    bpy.utils.unregister_class(MyMaterialProps)

if __name__ == "__main__":
    register()</literal_block>
                    <note>
                        <paragraph><emphasis>The class must be registered before being used in a property, failing to do so will raise an error:</emphasis></paragraph>
                        <paragraph><literal>ValueError: bpy_struct "Material" registration error: my_custom_props could not register</literal></paragraph>
                    </note>
                    <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve"># Create new property group with a sub property
# bpy.data.materials[0].my_custom_props.sub_group.my_float
import bpy

class MyMaterialSubProps(bpy.types.PropertyGroup):
    my_float = bpy.props.FloatProperty()

class MyMaterialGroupProps(bpy.types.PropertyGroup):
    sub_group = bpy.props.PointerProperty(type=MyMaterialSubProps)

def register():
    bpy.utils.register_class(MyMaterialSubProps)
    bpy.utils.register_class(MyMaterialGroupProps)
    bpy.types.Material.my_custom_props = bpy.props.PointerProperty(type=MyMaterialGroupProps)

def unregister():
    del bpy.types.Material.my_custom_props
    bpy.utils.unregister_class(MyMaterialGroupProps)
    bpy.utils.unregister_class(MyMaterialSubProps)

if __name__ == "__main__":
    register()</literal_block>
                    <note>
                        <paragraph><emphasis>The lower most class needs to be registered first and that unregister() is a mirror of register()</emphasis></paragraph>
                    </note>
                </section>
                <section ids="manipulating-classes" names="manipulating\ classes">
                    <title>Manipulating Classes</title>
                    <paragraph>Properties can be added and removed as Blender runs,
                        normally happens on register or unregister but for some
                        special cases it may be useful to modify types as the script runs.</paragraph>
                    <paragraph>For example:</paragraph>
                    <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve"># add a new property to an existing type
bpy.types.Object.my_float = bpy.props.FloatProperty()
# remove
del bpy.types.Object.my_float</literal_block>
                    <paragraph>This works just as well for PropertyGroup subclasses you define yourself.</paragraph>
                    <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">class MyPropGroup(bpy.types.PropertyGroup):
    pass
MyPropGroup.my_float = bpy.props.FloatProperty()</literal_block>
                    <paragraph>…this is equivalent to:</paragraph>
                    <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">class MyPropGroup(bpy.types.PropertyGroup):
    my_float = bpy.props.FloatProperty()</literal_block>
                </section>
                <section ids="dynamic-defined-classes-advanced" names="dynamic\ defined-classes\ (advanced)">
                    <title>Dynamic Defined-Classes (Advanced)</title>
                    <paragraph>In some cases the specifier for data may not be in Blender, renderman shader definitions
                        for example, and it may be useful to define them as types and remove them on the fly.</paragraph>
                    <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">for i in range(10):
    idname = "object.operator_%d" % i

    def func(self, context):
        print("Hello World", self.bl_idname)
        return {'FINISHED'}

    opclass = type("DynOp%d" % i,
                   (bpy.types.Operator, ),
                   {"bl_idname": idname, "bl_label": "Test", "execute": func},
                   )
    bpy.utils.register_class(opclass)</literal_block>
                    <note>
                        <paragraph><literal>type()</literal> is called to define the class.
                            This is an alternative syntax for class creation in Python, better suited to constructing classes dynamically.</paragraph>
                    </note>
                    <paragraph>To call the operators from the previous example:</paragraph>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.ops.object.operator_1()
Hello World OBJECT_OT_operator_1
{'FINISHED'}</doctest_block>
                    <doctest_block xml:space="preserve">&gt;&gt;&gt; bpy.ops.object.operator_2()
Hello World OBJECT_OT_operator_2
{'FINISHED'}</doctest_block>
                </section>
            </section>
        </section>
    </section>
</document>
