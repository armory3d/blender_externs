<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/media/rou/Seagate Expansion Drive/Programming_Projects/Linux2018/Tests/blender/doc/python_api/sphinx-in/info_tips_and_tricks.rst">
    <section ids="tips-and-tricks" names="tips\ and\ tricks">
        <title>Tips and Tricks</title>
        <paragraph>Here are various suggestions that you might find useful when writing scripts.</paragraph>
        <paragraph>Some of these are just Python features that scripters may not have thought to use with Blender,
            others are Blender specific.</paragraph>
        <target refid="use-the-terminal"></target>
        <section ids="use-the-terminal id1" names="use\ the\ terminal use_the_terminal">
            <title>Use The Terminal</title>
            <paragraph>When writing Python scripts, it’s useful to have a terminal open,
                this is not the built-in Python console but a terminal application which is used to start Blender.</paragraph>
            <paragraph>There are 3 main uses for the terminal, these are:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>You can see the output of <literal>print()</literal> as your script runs, which is useful to view debug info.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The error trace-back is printed in full to the terminal which won’t always generate an error popup in
                        Blender’s user interface (depending on how the script is executed).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If the script runs for too long or you accidentally enter an infinite loop,
                        <literal classes="kbd">Ctrl-C</literal> in the terminal (<literal classes="kbd">Ctrl-Break</literal> on Windows) will quit the script early.</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>For Linux and macOS users this means starting the terminal first, then running Blender from within it.
                    On Windows the terminal can be enabled from the help menu.</paragraph>
            </note>
        </section>
        <section ids="interface-tricks" names="interface\ tricks">
            <title>Interface Tricks</title>
            <section ids="access-operator-commands" names="access\ operator\ commands">
                <title>Access Operator Commands</title>
                <paragraph>You may have noticed that the tooltip for menu items and buttons includes the <literal>bpy.ops.[...])</literal> command
                    to run that button, a handy (hidden) feature is that you can press <literal classes="kbd">Ctrl-C</literal> over
                    any menu item/button to copy this command into the clipboard.</paragraph>
            </section>
            <section ids="access-data-path" names="access\ data\ path">
                <title>Access Data Path</title>
                <paragraph>To find the path from an <literal classes="xref py py-class">ID</literal> datablock to its setting isn’t always so simple since it may be nested away.
                    To get this quickly you can right click on the setting and select select <strong>Copy Data Path</strong>,
                    if this can’t be generated, only the property name is copied.</paragraph>
                <note>
                    <paragraph>This uses the same method for creating the animation path used by
                        <reference internal="True" reftitle="bpy.types.FCurve.data_path" refuri="bpy.types.FCurve#bpy.types.FCurve.data_path"><literal classes="xref py py-class">bpy.types.FCurve.data_path</literal></reference> and
                        <reference internal="True" reftitle="bpy.types.DriverTarget.data_path" refuri="bpy.types.DriverTarget#bpy.types.DriverTarget.data_path"><literal classes="xref py py-class">bpy.types.DriverTarget.data_path</literal></reference> drivers.</paragraph>
                </note>
                <target refid="info-show-all-operators"></target>
            </section>
        </section>
        <section ids="show-all-operators info-show-all-operators" names="show\ all\ operators info_show_all_operators">
            <title>Show All Operators</title>
            <paragraph>While Blender logs operators in the Info space,
                this only reports operators with the <literal>REGISTER</literal> option enabeld so as not to flood the <emphasis>Info</emphasis> view
                with calls to <literal>bpy.ops.view3d.smoothview</literal> and <literal>bpy.ops.view3d.zoom</literal>.</paragraph>
            <paragraph>However, for testing it can be useful to see <strong>every</strong> operator called in a terminal,
                do this by enabling the debug option either by passing the <literal>--debug-wm</literal> argument when starting Blender
                or by setting <reference internal="True" reftitle="bpy.app.debug_wm" refuri="bpy.app#bpy.app.debug_wm"><literal classes="xref py py-mod">bpy.app.debug_wm</literal></reference> to <literal>True</literal> while Blender is running.</paragraph>
        </section>
        <section ids="use-an-external-editor" names="use\ an\ external\ editor">
            <title>Use an External Editor</title>
            <paragraph>Blenders text editor is fine for small changes and writing tests but its not full featured,
                for larger projects you’ll probably want to use a standalone editor or Python IDE.</paragraph>
            <paragraph>Editing a text file externally and having the same text open in Blender does work but isn’t that optimal
                so here are 2 ways you can easily use an external file from Blender.</paragraph>
            <paragraph>Using the following examples you’ll still need textblock in Blender to execute,
                but reference an external file rather than including it directly.</paragraph>
            <section ids="executing-external-scripts" names="executing\ external\ scripts">
                <title>Executing External Scripts</title>
                <paragraph>This is the equivalent to running the script directly, referencing a scripts path from a 2 line text-block.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">filename = "/full/path/to/myscript.py"
exec(compile(open(filename).read(), filename, 'exec'))</literal_block>
                <paragraph>You might want to reference a script relative to the blend file.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">import bpy
import os

filename = os.path.join(os.path.dirname(bpy.data.filepath), "myscript.py")
exec(compile(open(filename).read(), filename, 'exec'))</literal_block>
            </section>
            <section ids="executing-modules" names="executing\ modules">
                <title>Executing Modules</title>
                <paragraph>This example shows loading a script in as a module and executing a module function.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">import myscript
import importlib

importlib.reload(myscript)
myscript.main()</literal_block>
                <paragraph>Notice that the script is reloaded every time, this forces use of the modified version,
                    otherwise the cached one in <literal>sys.modules</literal> would be used until Blender was restarted.</paragraph>
                <paragraph>The important difference between this and executing the script directly is it
                    has to call a function in the module, in this case <literal>main()</literal> but it can be any function,
                    an advantage with this is you can pass arguments to the function from this
                    small script which is often useful for testing different settings quickly.</paragraph>
                <paragraph>The other issue with this is the script has to be in Pythons module search path.
                    While this is not best practice - for testing you can extend the search path,
                    this example adds the current blend files directory to the search path, then loads the script as a module.</paragraph>
                <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">import sys
import os
import bpy

blend_dir = os.path.dirname(bpy.data.filepath)
if blend_dir not in sys.path:
   sys.path.append(blend_dir)

import myscript
import importlib
importlib.reload(myscript)
myscript.main()</literal_block>
            </section>
        </section>
        <section ids="don-t-use-blender" names="don't\ use\ blender!">
            <title>Don’t Use Blender!</title>
            <paragraph>While developing your own scripts Blenders interface can get in the way,
                manually reloading, running the scripts, opening file import etc. adds overhead.</paragraph>
            <paragraph>For scripts that are not interactive it can end up being more efficient not to use
                Blenders interface at all and instead execute the script on the command line.</paragraph>
            <literal_block highlight_args="{}" language="sh" linenos="False" xml:space="preserve">blender --background --python myscript.py</literal_block>
            <paragraph>You might want to run this with a blend file so the script has some data to operate on.</paragraph>
            <literal_block highlight_args="{}" language="sh" linenos="False" xml:space="preserve">blender myscene.blend --background --python myscript.py</literal_block>
            <note>
                <paragraph>Depending on your setup you might have to enter the full path to the Blender executable.</paragraph>
            </note>
            <paragraph>Once the script is running properly in background mode, you’ll want to check the output of the script,
                this depends completely on the task at hand however here are some suggestions.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>render the output to an image, use an image viewer and keep writing over the same image each time.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>save a new blend file, or export the file using one of Blenders exporters.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>if the results can be displayed as text - print them or write them to a file.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>While this can take a little time to setup, it can be well worth the effort
                to reduce the time it takes to test changes - you can even have
                Blender running the script every few seconds with a viewer updating the results,
                so no need to leave your text editor to see changes.</paragraph>
        </section>
        <section ids="use-external-tools" names="use\ external\ tools">
            <title>Use External Tools</title>
            <paragraph>When there are no readily available Python modules to perform specific tasks it’s
                worth keeping in mind you may be able to have Python execute an external command
                on your data and read the result back in.</paragraph>
            <paragraph>Using external programs adds an extra dependency and may limit who can use the script
                but to quickly setup your own custom pipeline or writing one-off scripts this can be handy.</paragraph>
            <paragraph>Examples include:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Run The Gimp in batch mode to execute custom scripts for advanced image processing.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Write out 3D models to use external mesh manipulation tools and read back in the results.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Convert files into recognizable formats before reading.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="bundled-python-extensions" names="bundled\ python\ &amp;\ extensions">
            <title>Bundled Python &amp; Extensions</title>
            <paragraph>The Blender releases distributed from blender.org include a complete Python installation on all platforms,
                this has the disadvantage that any extensions you have installed in your systems Python won’t be found by Blender.</paragraph>
            <paragraph>There are 2 ways around this:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Remove Blender Python sub-directory, Blender will then fallback on the systems Python and use that instead.</paragraph>
                    <paragraph>Depending on your platform,
                        you may need to explicitly reference the location of your Python installation using the
                        <literal>PYTHONPATH</literal> environment variable, eg:</paragraph>
                    <literal_block highlight_args="{}" language="sh" linenos="False" xml:space="preserve">PYTHONPATH=/usr/lib/python3.5 ./blender</literal_block>
                    <warning>
                        <paragraph>The Python version must match the one that Blender comes with.</paragraph>
                    </warning>
                </list_item>
                <list_item>
                    <paragraph>Copy or link the extensions into Blender’s Python sub-directory so Blender can access them,
                        you could also copy the entire Python installation into Blenders sub-directory,
                        replacing the one Blender comes with.
                        This works as long as the Python versions match and the paths are created in the same relative locations.
                        Doing this has the advantage that you can redistribute this bundle to others with Blender
                        including any extensions you rely on.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="drop-into-a-python-interpreter-in-your-script" names="drop\ into\ a\ python\ interpreter\ in\ your\ script">
            <title>Drop Into a Python Interpreter in Your Script</title>
            <paragraph>In the middle of a script you may want to inspect some variables,
                run some function and generally dig about to see whats going on.</paragraph>
            <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">import code
code.interact(local=locals())</literal_block>
            <paragraph>If you want to access both global and local variables do this…</paragraph>
            <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">import code
namespace = globals().copy()
namespace.update(locals())
code.interact(local=namespace)</literal_block>
            <paragraph>The next example is an equivalent single line version of the script above which is easier to paste into your code:</paragraph>
            <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">__import__('code').interact(local=dict(globals(), **locals()))</literal_block>
            <paragraph><literal>code.interact</literal> can be added at any line in the script
                and will pause the script an launch an interactive interpreter in the terminal,
                when you’re done you can quit the interpreter and the script will continue execution.</paragraph>
            <paragraph>If you have <strong>IPython</strong> installed you can use its <literal>embed()</literal> function which uses the current namespace.
                The IPython prompt has auto-complete and some useful features that the standard Python eval-loop doesn’t have.</paragraph>
            <literal_block highlight_args="{}" language="python" linenos="False" xml:space="preserve">import IPython
IPython.embed()</literal_block>
            <paragraph>Admittedly this highlights the lack of any Python debugging support built into Blender, but its still handy to know.</paragraph>
        </section>
        <section ids="advanced" names="advanced">
            <title>Advanced</title>
            <section ids="blender-as-a-module" names="blender\ as\ a\ module">
                <title>Blender as a module</title>
                <paragraph>From a Python perspective it’s nicer to have everything as an extension
                    which lets the Python script combine many components.</paragraph>
                <paragraph>Advantages include:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>you can use external editors/IDE’s with Blenders Python API and execute scripts within the IDE
                            (step over code, inspect variables as the script runs).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>editors/IDE’s can auto complete Blender modules &amp; variables.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>existing scripts can import Blender API’s without having to run inside Blender.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>This is marked advanced because to run Blender as a Python module requires a special build option.</paragraph>
                <paragraph>For instructions on building see
                    <reference name="Building Blender as a Python module" refuri="https://wiki.blender.org/index.php/User:Ideasman42/BlenderAsPyModule">Building Blender as a Python module</reference><target ids="building-blender-as-a-python-module" names="building\ blender\ as\ a\ python\ module" refuri="https://wiki.blender.org/index.php/User:Ideasman42/BlenderAsPyModule"></target></paragraph>
            </section>
            <section ids="python-safety-build-option" names="python\ safety\ (build\ option)">
                <title>Python Safety (Build Option)</title>
                <paragraph>Since it’s possible to access data which has been removed (see Gotcha’s),
                    this can be hard to track down the cause of crashes.</paragraph>
                <paragraph>To raise Python exceptions on accessing freed data (rather than crashing),
                    enable the CMake build option <literal>WITH_PYTHON_SAFETY</literal>.</paragraph>
                <paragraph>This enables data tracking which makes data access about 2x slower
                    which is why the option isn’t enabled in release builds.</paragraph>
            </section>
        </section>
    </section>
</document>
